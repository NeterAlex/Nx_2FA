/**
 * JavaScript TOTP (Time-based One-Time Password) Implementation
 * Based on RFC 6238
 */

(function (global) {
	"use strict";

	const jsOTP = {};

	// Base32 decoding
	const base32Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	const base32Map = {};
	for (let i = 0; i < base32Chars.length; i++) {
		base32Map[base32Chars[i]] = i;
	}

	function base32Decode(encoded) {
		// Remove padding
		encoded = encoded.replace(/=/g, "");

		const output = [];
		let bits = 0;
		let value = 0;

		for (let i = 0; i < encoded.length; i++) {
			const char = encoded[i].toUpperCase();
			if (!(char in base32Map)) {
				throw new Error(`Invalid character in base32: ${char}`);
			}

			value = (value << 5) | base32Map[char];
			bits += 5;

			if (bits >= 8) {
				output.push((value >>> (bits - 8)) & 255);
				bits -= 8;
			}
		}

		return new Uint8Array(output);
	}

	// HMAC-SHA1 implementation
	async function hmacSha1(key, message) {
		const cryptoKey = await crypto.subtle.importKey(
			"raw",
			key,
			{ name: "HMAC", hash: "SHA-1" },
			false,
			["sign"],
		);

		const signature = await crypto.subtle.sign("HMAC", cryptoKey, message);
		return new Uint8Array(signature);
	}

	// Synchronous HMAC-SHA1 fallback using simple hash
	function hmacSha1Sync(key, message) {
		// This is a simplified implementation for demonstration
		// In a real application, you might want to use a more robust crypto library
		const blockSize = 64;
		const outputSize = 20;

		if (key.length > blockSize) {
			// If key is longer than block size, hash it
			key = simpleSha1(key);
		}

		if (key.length < blockSize) {
			// Pad key with zeros
			const paddedKey = new Uint8Array(blockSize);
			paddedKey.set(key);
			key = paddedKey;
		}

		const ipadKey = new Uint8Array(blockSize);
		const opadKey = new Uint8Array(blockSize);

		for (let i = 0; i < blockSize; i++) {
			ipadKey[i] = key[i] ^ 0x36;
			opadKey[i] = key[i] ^ 0x5c;
		}

		// Inner hash
		const innerMessage = new Uint8Array(blockSize + message.length);
		innerMessage.set(ipadKey);
		innerMessage.set(message, blockSize);
		const innerHash = simpleSha1(innerMessage);

		// Outer hash
		const outerMessage = new Uint8Array(blockSize + outputSize);
		outerMessage.set(opadKey);
		outerMessage.set(innerHash, blockSize);

		return simpleSha1(outerMessage);
	}

	// Simplified SHA-1 implementation (for educational purposes)
	function simpleSha1(data) {
		// This is a very basic implementation
		// In production, use Web Crypto API or a proper crypto library

		// Convert data to array if needed
		if (!(data instanceof Uint8Array)) {
			data = new Uint8Array(data);
		}

		// Initialize hash values
		let h0 = 0x67452301;
		let h1 = 0xefcdab89;
		let h2 = 0x98badcfe;
		let h3 = 0x10325476;
		let h4 = 0xc3d2e1f0;

		// Pre-processing: adding padding bits
		const msgLength = data.length;
		const bitLength = msgLength * 8;

		// Padding
		const paddedLength = Math.ceil((msgLength + 9) / 64) * 64;
		const padded = new Uint8Array(paddedLength);
		padded.set(data);
		padded[msgLength] = 0x80;

		// Length in bits as 64-bit big-endian
		const view = new DataView(padded.buffer);
		view.setUint32(paddedLength - 4, bitLength, false);

		// Process message in 512-bit chunks
		for (let chunkStart = 0; chunkStart < paddedLength; chunkStart += 64) {
			const w = new Uint32Array(80);

			// Break chunk into sixteen 32-bit big-endian words
			for (let i = 0; i < 16; i++) {
				w[i] = view.getUint32(chunkStart + i * 4, false);
			}

			// Extend the sixteen 32-bit words into eighty 32-bit words
			for (let i = 16; i < 80; i++) {
				w[i] = leftRotate(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16], 1);
			}

			// Initialize hash value for this chunk
			let a = h0,
				b = h1,
				c = h2,
				d = h3,
				e = h4;

			// Main loop
			for (let i = 0; i < 80; i++) {
				let f, k;
				if (i < 20) {
					f = (b & c) | (~b & d);
					k = 0x5a827999;
				} else if (i < 40) {
					f = b ^ c ^ d;
					k = 0x6ed9eba1;
				} else if (i < 60) {
					f = (b & c) | (b & d) | (c & d);
					k = 0x8f1bbcdc;
				} else {
					f = b ^ c ^ d;
					k = 0xca62c1d6;
				}

				const temp = (leftRotate(a, 5) + f + e + k + w[i]) >>> 0;
				e = d;
				d = c;
				c = leftRotate(b, 30);
				b = a;
				a = temp;
			}

			// Add this chunk's hash to result so far
			h0 = (h0 + a) >>> 0;
			h1 = (h1 + b) >>> 0;
			h2 = (h2 + c) >>> 0;
			h3 = (h3 + d) >>> 0;
			h4 = (h4 + e) >>> 0;
		}

		// Produce the final hash value as a 160-bit number
		const result = new Uint8Array(20);
		const resultView = new DataView(result.buffer);
		resultView.setUint32(0, h0, false);
		resultView.setUint32(4, h1, false);
		resultView.setUint32(8, h2, false);
		resultView.setUint32(12, h3, false);
		resultView.setUint32(16, h4, false);

		return result;
	}

	function leftRotate(n, b) {
		return ((n << b) | (n >>> (32 - b))) >>> 0;
	}

	// TOTP class
	jsOTP.totp = function (options) {
		options = options || {};
		this.window = options.window || 0;
		this.digits = options.digits || 6;
		this.period = options.period || 30;
		this.algorithm = options.algorithm || "SHA1";
	};

	jsOTP.totp.prototype.getOtp = function (secret, timestamp) {
		if (typeof secret === "string") {
			secret = base32Decode(secret);
		}

		timestamp = timestamp || Math.floor(Date.now() / 1000);
		const timeStep = Math.floor(timestamp / this.period);

		return this.generateOtp(secret, timeStep);
	};

	jsOTP.totp.prototype.generateOtp = function (secret, counter) {
		// Convert counter to 8-byte big-endian
		const counterBytes = new Uint8Array(8);
		const counterView = new DataView(counterBytes.buffer);
		counterView.setUint32(4, counter, false); // Big-endian

		// Generate HMAC
		const hmac = hmacSha1Sync(secret, counterBytes);

		// Dynamic truncation
		const offset = hmac[hmac.length - 1] & 0x0f;
		const code =
			((hmac[offset] & 0x7f) << 24) |
			((hmac[offset + 1] & 0xff) << 16) |
			((hmac[offset + 2] & 0xff) << 8) |
			(hmac[offset + 3] & 0xff);

		// Generate digits
		const otp = code % Math.pow(10, this.digits);
		return otp.toString().padStart(this.digits, "0");
	};

	jsOTP.totp.prototype.verify = function (token, secret, timestamp, window) {
		window = window || this.window;
		timestamp = timestamp || Math.floor(Date.now() / 1000);

		for (let i = -window; i <= window; i++) {
			const testTime = timestamp + i * this.period;
			if (this.getOtp(secret, testTime) === token) {
				return true;
			}
		}
		return false;
	};

	// Export for different environments
	if (typeof module !== "undefined" && module.exports) {
		module.exports = jsOTP;
	} else if (typeof define === "function" && define.amd) {
		define(function () {
			return jsOTP;
		});
	} else {
		global.jsOTP = jsOTP;
	}
})(typeof window !== "undefined" ? window : this);
